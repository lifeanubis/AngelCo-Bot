#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module) {

module.exports = JSON.parse("{\"options\":[{\"format\":null,\"description\":null,\"question\":{\"type\":null,\"name\":null,\"initial\":null,\"message\":null}},{\"format\":null,\"description\":null,\"question\":{\"type\":null,\"name\":null,\"initial\":null,\"message\":null}}],\"commands\":[{\"name\":\"automate\",\"alias\":null,\"description\":null,\"arguments\":{\"format\":null,\"questions\":[{\"type\":null,\"name\":null,\"initial\":null,\"prompt\":false,\"message\":null}]},\"options\":[{\"format\":null,\"description\":null,\"question\":{\"type\":null,\"name\":null,\"initial\":null,\"prompt\":false,\"message\":null}}]}]}");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("puppeteer");

/***/ }),
/* 2 */
/***/ (function(module) {

module.exports = JSON.parse("{\"information\":{\"credentials\":{\"username\":null,\"password\":null},\"links\":{\"root\":\"about:blank\",\"login\":null},\"selectors\":{\"login\":{\"username\":null,\"password\":null,\"submit\":null}}},\"settings\":{\"browser\":{\"ignoreHTTPSErrors\":true,\"headless\":false,\"defaultViewport\":null,\"timeout\":0},\"page\":{\"waitUntil\":\"networkidle0\",\"timeout\":0,\"static\":{\"waitUntil\":\"networkidle0\",\"timeout\":0},\"dynamic\":{\"waitUntil\":\"networkidle2\",\"timeout\":0}}}}");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("ramda");

/***/ }),
/* 4 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"raita\",\"version\":\"0.0.1\",\"messages\":{\"intro\":\"raita\",\"outro\":\"bye.\"}}");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("chalk");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("boxen");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("figlet");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("terminal-link");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("gradient-string");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("chalk-animation");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("cfonts");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("cli-format");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("enquirer");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("commander");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("json2csv");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("csvtojson");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("shelljs.exec");

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/settings/application.yaml
var settings_application = __webpack_require__(4);

// EXTERNAL MODULE: ./src/settings/configuration.yaml
var settings_configuration = __webpack_require__(0);

// EXTERNAL MODULE: external "ramda"
var external_ramda_ = __webpack_require__(3);
var external_ramda_default = /*#__PURE__*/__webpack_require__.n(external_ramda_);

// EXTERNAL MODULE: external "chalk"
var external_chalk_ = __webpack_require__(5);
var external_chalk_default = /*#__PURE__*/__webpack_require__.n(external_chalk_);

// EXTERNAL MODULE: external "boxen"
var external_boxen_ = __webpack_require__(6);
var external_boxen_default = /*#__PURE__*/__webpack_require__.n(external_boxen_);

// EXTERNAL MODULE: external "figlet"
var external_figlet_ = __webpack_require__(7);
var external_figlet_default = /*#__PURE__*/__webpack_require__.n(external_figlet_);

// EXTERNAL MODULE: external "terminal-link"
var external_terminal_link_ = __webpack_require__(8);
var external_terminal_link_default = /*#__PURE__*/__webpack_require__.n(external_terminal_link_);

// EXTERNAL MODULE: external "gradient-string"
var external_gradient_string_ = __webpack_require__(9);
var external_gradient_string_default = /*#__PURE__*/__webpack_require__.n(external_gradient_string_);

// EXTERNAL MODULE: external "chalk-animation"
var external_chalk_animation_ = __webpack_require__(10);
var external_chalk_animation_default = /*#__PURE__*/__webpack_require__.n(external_chalk_animation_);

// EXTERNAL MODULE: external "cfonts"
var external_cfonts_ = __webpack_require__(11);
var external_cfonts_default = /*#__PURE__*/__webpack_require__.n(external_cfonts_);

// EXTERNAL MODULE: external "cli-format"
var external_cli_format_ = __webpack_require__(12);
var external_cli_format_default = /*#__PURE__*/__webpack_require__.n(external_cli_format_);

// CONCATENATED MODULE: ./src/components/elements/text.js
/*
  ======================================

     /$$                           /$$
    | $$                          | $$
   /$$$$$$    /$$$$$$  /$$   /$$ /$$$$$$
  |_  $$_/   /$$__  $$|  $$ /$$/|_  $$_/
    | $$    | $$$$$$$$ \  $$$$/   | $$
    | $$ /$$| $$_____/  >$$  $$   | $$ /$$
    |  $$$$/|  $$$$$$$ /$$/\  $$  |  $$$$/
     \___/   \_______/|__/  \__/   \___/

   Usage: import text from "components/elements/text"

   and then you can use either of the functions mentioned
   below. You should also checkout the docs of
   dependencies that this file uses while working
   with it because they're very short and provide a
   much richer documentation.

  ======================================
*/









/* harmony default export */ var elements_text = ({
  basic: external_chalk_default.a,
  link: external_terminal_link_default.a,
  format: external_cli_format_default.a,
  gradient: external_gradient_string_default.a,
  animation: external_chalk_animation_default.a,

  heading(content) {
    /*
      ======================================
        This function returns a figlet header
        without a box surrounding it. If you
        want the box or gradient, you can pipe
        or compose these functions together because
        return values for all of these calls is a string.
      ======================================
    */
    return external_figlet_default.a.textSync(content, {
      font: "Standard",
      horizontalLayout: "fitted",
      verticalLayout: "default"
    });
  },

  fancy(content, options = {}) {
    return external_cfonts_default.a.render(content, {
      font: "tiny",
      align: "left",
      colors: ["system"],
      background: "transparent",
      letterSpacing: 1,
      lineHeight: 1,
      space: false,
      maxLength: "0",
      gradient: false,
      independentGradient: false,
      transitionGradient: false,
      env: "node",
      ...options
    }).string;
  },

  boxed(string, options = {}) {
    /*
      ======================================
        This function optionally takes arguments
        and uses `boxen` package to create boxes
        surrounding some string in the terminal.
        You can pass in options to the call if you
        want to override default behavior. Look
        for boxen's npm docs to know how to do that.
      ======================================
    */
    return external_boxen_default()(string, {
      padding: 1,
      borderStyle: "bold",
      ...options
    });
  },

  tag(string, options = {}) {
    /*
      ======================================
        This function returns a pipe of
        `boxed`` and `gradient`. So that means you'll
        get some colorful boxed string. Unlike
        `banner`, it doesn't turn the string big, so
        it can be seen as a tag. Useful in some cases.
      ======================================
    */
    const gradient = options.gradient ? options.gradient : "fruit";
    return external_ramda_default.a.pipe(string => this.basic(string), string => this.boxed(string, {
      padding: {
        left: 1,
        right: 1,
        top: 0,
        bottom: 0
      },
      borderStyle: "bold"
    }), string => this.gradient[gradient](string))(string);
  },

  banner(string, options = {}) {
    /*
      ======================================
        This function is a pipe of some functions
        above and essentially it creates a big and
        boxed colorful header on the terminal.
      ======================================
    */
    const gradient = options.gradient ? options.gradient : "fruit";
    return external_ramda_default.a.pipe(string => this.basic(string), string => this.heading(string), string => this.boxed(string, {
      margin: {
        bottom: 1
      }
    }), string => this.gradient[gradient](string))(string);
  },

  poster(string, options = {}) {
    /*
      ======================================
        This function is a pipe of some functions
        above and essentially it creates a big and
        boxed colorful header on the terminal.
      ======================================
    */
    const gradient = options.gradient ? options.gradient : "yellow,blue";
    return external_ramda_default.a.pipe(string => this.basic(string), string => this.fancy(string, {
      gradient: gradient
    }), string => this.boxed(string, {
      margin: {
        bottom: 1
      }
    }))(string);
  }

});
// EXTERNAL MODULE: external "enquirer"
var external_enquirer_ = __webpack_require__(13);
var external_enquirer_default = /*#__PURE__*/__webpack_require__.n(external_enquirer_);

// CONCATENATED MODULE: ./src/components/elements/prompt.js
/*
  ======================================
                                                           /$$
                                                          | $$
    /$$$$$$   /$$$$$$   /$$$$$$  /$$$$$$/$$$$   /$$$$$$  /$$$$$$
   /$$__  $$ /$$__  $$ /$$__  $$| $$_  $$_  $$ /$$__  $$|_  $$_/
  | $$  \ $$| $$  \__/| $$  \ $$| $$ \ $$ \ $$| $$  \ $$  | $$
  | $$  | $$| $$      | $$  | $$| $$ | $$ | $$| $$  | $$  | $$ /$$
  | $$$$$$$/| $$      |  $$$$$$/| $$ | $$ | $$| $$$$$$$/  |  $$$$/
  | $$____/ |__/       \______/ |__/ |__/ |__/| $$____/    \___/
  | $$                                        | $$
  | $$                                        | $$
  |__/                                        |__/

    Usage:

    import prompts from "components/elements/prompts"
    const answers = await prompts(<questions>)

    To figure out the structure of 'questions'
    and available types, checkout npm docs for enquirer here:
    https://www.npmjs.com/package/enquirer

  ======================================
*/

const enquirer = new external_enquirer_default.a();

const prompter = questions => enquirer.prompt(questions);

/* harmony default export */ var elements_prompt = (async questions => await prompter(questions));
// CONCATENATED MODULE: ./src/components/organisms/interactive/index.js


/* harmony default export */ var interactive = (async settings => {
  /*
    ======================================
       This function prints out the banner
      first, from the information provided
      in `application.yaml` file. Then
      it questions the user based on a file inside settings and
      calls the default script specified inside
      `scripts` folder: passing it the answers that
      user has given to those questions.
       Whether or not things don't work inside that function,
      it exits out printing the exit message.
     ======================================
  */
  const {
    options,
    data
  } = settings;
  const {
    application,
    configuration
  } = data;
  const intro = application.messages.intro ? elements_text.poster(application.messages.intro) : null;
  const outro = application.messages.outro ? elements_text.basic.dim(`\n${application.messages.outro}`) : null;
  if (intro) console.log(intro);

  try {
    const answers = await elements_prompt(configuration.options.map(option => option.question));
    answers["version"] = application.version;
    await options(answers);
  } finally {
    if (outro) console.log(outro);
  }
});
// EXTERNAL MODULE: external "commander"
var external_commander_ = __webpack_require__(14);
var external_commander_default = /*#__PURE__*/__webpack_require__.n(external_commander_);

// CONCATENATED MODULE: ./src/components/organisms/traditional/index.js

/* harmony default export */ var traditional = (async settings => {
  /*
    ======================================
      This handles the route when user
      doesn't want an interactive route,
      so he passes some flags in to do
      the task.
    ======================================
  */
  const {
    program
  } = external_commander_default.a;
  const {
    options,
    commands,
    data
  } = settings;
  const {
    application,
    configuration
  } = data;
  /*
    ======================================
      Specifying information about the
      program itself - name, version.
    ======================================
  */

  program.storeOptionsAsProperties(false).passCommandToAction(false);
  program.name(application.name).version(application.version, "-v --version");
  /*
    ======================================
      Binding global level parameters or
      command line options to the program
      from the file that inside 'settings'
      folder.
    ======================================
  */

  if (configuration.options) {
    configuration.options.forEach(option => {
      if (option.format) {
        const description = option.description ? option.description : "";
        const defaultValue = option.question ? option.question.initial ? option.question.initial : null : null;
        program.option(option.format, option.description, defaultValue);
      }
    });
  }
  /*
    ======================================
      Binding global level commands and
      their options to the program.
    ======================================
  */


  if (configuration.commands) {
    configuration.commands.forEach(command => {
      if (command.name) {
        const c = program.createCommand(command.name);
        c.storeOptionsAsProperties(false);
        if (command.alias) c.alias(command.alias);
        if (command.arguments.format) c.arguments(command.arguments.format);
        const options = command.options ? command.options : [];
        options.forEach(option => {
          if (option.format) {
            const description = options.description ? options.description : "";
            const defaultValue = option.question ? option.question.initial ? option.question.initial : null : null;
            c.option(option.format, description, defaultValue);
          }
        });
        c.action(commands(command.name));
        program.addCommand(c);
      }
    });
  }
  /*
    ======================================
      Reading the argument list provided
      to the program and providing it
      to the controller 'program' variable.
    ======================================
  */


  await program.parseAsync(process.argv);
  process.exit();
});
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(15);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: external "json2csv"
var external_json2csv_ = __webpack_require__(16);
var external_json2csv_default = /*#__PURE__*/__webpack_require__.n(external_json2csv_);

// EXTERNAL MODULE: external "csvtojson"
var external_csvtojson_ = __webpack_require__(17);
var external_csvtojson_default = /*#__PURE__*/__webpack_require__.n(external_csvtojson_);

// CONCATENATED MODULE: ./src/components/elements/csv.js



/* harmony default export */ var csv = ({
  write: async (array, location, options = {}) => {
    /*
      ======================================
        Data must be an array of objects.
        The keys of the object may or may
        not be same but they're the ones
        that'll form the columns of the CSV.
      ======================================
    */
    const converted = external_json2csv_default.a.parse(array, {
      fields: Object.keys(array[0])
    });
    if (location) await external_fs_default.a.writeFileSync(location, converted);
    return await converted;
  },
  read: async location => {
    /*
      ======================================
        The file must exist, that's all.
        It'll read in a CSV and then return
        an object, which will be valid JSON data.
      ======================================
    */
    return await external_csvtojson_default()().fromFile(location);
  }
});
// EXTERNAL MODULE: external "puppeteer"
var external_puppeteer_ = __webpack_require__(1);
var external_puppeteer_default = /*#__PURE__*/__webpack_require__.n(external_puppeteer_);

// EXTERNAL MODULE: external "shelljs.exec"
var external_shelljs_exec_ = __webpack_require__(18);
var external_shelljs_exec_default = /*#__PURE__*/__webpack_require__.n(external_shelljs_exec_);

// CONCATENATED MODULE: ./src/components/elements/shell.js
/*
  ======================================

               /$$                 /$$ /$$
              | $$                | $$| $$
      /$$$$$$$| $$$$$$$   /$$$$$$ | $$| $$
     /$$_____/| $$__  $$ /$$__  $$| $$| $$
    |  $$$$$$ | $$  \ $$| $$$$$$$$| $$| $$
     \____  $$| $$  | $$| $$_____/| $$| $$
     /$$$$$$$/| $$  | $$|  $$$$$$$| $$| $$
    |_______/ |__/  |__/ \_______/|__/|__/

    This component *almost* resembles a shell.
    First argument is name of the command,
    second is an array of options following it.
    And it's always synchronous so you don't
    have to worry a lot about dealing with
    other stuff.

  ======================================
*/

/* harmony default export */ var shell = ((command, options = {}) => external_shelljs_exec_default()(command || "", { ...options
}));
// EXTERNAL MODULE: ./src/settings/automation.yaml
var automation = __webpack_require__(2);

// CONCATENATED MODULE: ./src/program/arguments.js






async function angel(p, url, ps) {
  // let chillu = []
  // let pillu = []
  await p.goto(url, ps);
  await p.type("#user_email", "code.shreyansh@gmail.com", {
    delay: 100
  });
  await p.type("#user_password", "jai shiva ji", {
    delay: 100
  });
  await p.click("input[type=submit]", {
    delay: 10
  });
  await p.waitForNavigation();

  for (let i = 0; i <= 200; i++) {
    const i = await p.keyboard.press("Space", {
      delay: 10
    });
    console.log("hsdfkjsh");
  }

  const name = await p.$$eval(".component_4d072 a", name => name.map(names => {
    const obj = {
      value2: names.href
    };
    return obj;
  })); // const jaankari = await p.$$eval(".content_1ca23 a", (jaankari) => jaankari.map((jaan) => jaan.href))
  // let pillu = name.slice(0, 30)
  // let chillu = jaankari.slice(0, 10)

  return name;
}

/* harmony default export */ var program_arguments = (async data => {
  const {
    options
  } = data;
  const {
    information,
    settings
  } = automation;
  let chotu = [];
  const browser = await external_puppeteer_default.a.launch(settings.browser);
  const page = await browser.newPage();
  const url = "https://angel.co/login";
  let l = await angel(page, url, settings.page.static);
  await csv.write(l, "trip.csv");
  console.log(l);
  console.log("hare krishna"); // await page.goto("https://www.youtube.com/", settings.page.static)
  // for (let i = 0; i <= 100; i++) {
  //   const i = await page.keyboard.press("Tab")
  //   console.log("hsdfkjsh")
  // }
});
// CONCATENATED MODULE: ./src/components/organisms/interactive/routes.js
/*
  ======================================

                           /$$     /$$
                          | $$    |__/
      /$$$$$$   /$$$$$$  /$$$$$$   /$$  /$$$$$$  /$$$$$$$   /$$$$$$$
     /$$__  $$ /$$__  $$|_  $$_/  | $$ /$$__  $$| $$__  $$ /$$_____/
    | $$  \ $$| $$  \ $$  | $$    | $$| $$  \ $$| $$  \ $$|  $$$$$$
    | $$  | $$| $$  | $$  | $$ /$$| $$| $$  | $$| $$  | $$ \____  $$
    |  $$$$$$/| $$$$$$$/  |  $$$$/| $$|  $$$$$$/| $$  | $$ /$$$$$$$/
     \______/ | $$____/    \___/  |__/ \______/ |__/  |__/|_______/
              | $$
              | $$
              |__/

    This is the script that does something with the options
    specified by the user either though traditional CLI or
    through interactive CLI modes. This file is simply for
    dealing with the logic for options of the program.

  ======================================
*/



/* harmony default export */ var routes = (async options => {
  await program_arguments({
    options
  });
});
// CONCATENATED MODULE: ./src/components/molecules/automate.js





/* harmony default export */ var automate = (async data => {
  const {
    args,
    options,
    configuration
  } = data;
  const {
    information,
    settings
  } = automation;
  const browser = await external_puppeteer_default.a.launch(settings.browser);
  const page = await browser.newPage();

  try {
    /*
        ======================================
          This is where the automation or scraping
          code goes. Try to re-use the page variable
          whenever you want to visit multiple pages.
          You're supposed to remove this
          comment and start working here.
        ======================================
      */
    await page.goto(information.links.root, settings.page.static);
    await page.waitForNavigation();
  } catch (e) {
    /*
        ======================================
          After everything happens, we're trying
          to catch errors over here. Try to handle
          all errors for debugging ease.
        ======================================
      */
    throw new Error(e);
  } finally {
    /*
        ======================================
          And finally, after all this we're going
          to close our page and browser. You're
          supposed to cache URLs and reuse the 'page'
          variable instead of creating multiple pages.
          This will force you write faster code.
        ======================================
      */
    await page.close();
    await browser.close();
  }

  return {};
});
// CONCATENATED MODULE: ./src/program/commands.js

/* harmony default export */ var program_commands = ({
  automate: automate
});
// CONCATENATED MODULE: ./src/components/organisms/traditional/routes.js
/*
  ======================================
                                                                             /$$
                                                                            | $$
    /$$$$$$$  /$$$$$$  /$$$$$$/$$$$  /$$$$$$/$$$$   /$$$$$$  /$$$$$$$   /$$$$$$$  /$$$$$$$
   /$$_____/ /$$__  $$| $$_  $$_  $$| $$_  $$_  $$ |____  $$| $$__  $$ /$$__  $$ /$$_____/
  | $$      | $$  \ $$| $$ \ $$ \ $$| $$ \ $$ \ $$  /$$$$$$$| $$  \ $$| $$  | $$|  $$$$$$
  | $$      | $$  | $$| $$ | $$ | $$| $$ | $$ | $$ /$$__  $$| $$  | $$| $$  | $$ \____  $$
  |  $$$$$$$|  $$$$$$/| $$ | $$ | $$| $$ | $$ | $$|  $$$$$$$| $$  | $$|  $$$$$$$ /$$$$$$$/
   \_______/ \______/ |__/ |__/ |__/|__/ |__/ |__/ \_______/|__/  |__/ \_______/|_______/

  This file handles all sub-commands of this program.
  You specify the command handler in the 'commands'
  object below. 'key' in the command variable
  must match with `command.name` specified in some
  file in settings.

  ======================================
*/



const routes_commands = {
  __example: async data => {
    const {
      args,
      options,
      configuration
    } = data;
  },
  ...program_commands
};

const sanitize = settings => command => async (...options) => {
  /*
    ======================================
      This function sanitizes arguments that
      our commands will get. Commands are specified
      above. First, if the user types the command
      name but doesn't provide any arguments
      or options, then the CLI should ask
      for the arguments and options interactively.
    ======================================
  */
  if (Array.isArray(options) && options.length > 0) {
    /*
        ======================================
          If the options is an array, it means
          that user has used the CLI in traditional way.
          If this is the case, then the arguments need
          to be filtered differently for core functionality
          to apply.
        ======================================
      */
    const info = options[options.length - 1];

    const parser = (e, i) => ({
      [e.name]: options.slice(0, -1)[i]
    });

    const args = {};

    for (let p of info._args.map(parser)) {
      const key = Object.keys(p)[0];
      const value = p[key];
      args[key] = value;
    }

    let questions = {
      arguments: settings.arguments.questions.filter(q => q.prompt && q.prompt === true).filter(q => !args.hasOwnProperty(q.name) || args[q.name] === null || args[q.name] === q.initial),
      options: settings.options.map(o => o.question).filter(q => q.prompt && q.prompt === true).filter(q => !info._optionValues.hasOwnProperty(q.name) || info._optionValues[q.name] === null || info._optionValues[q.name] === q.initial)
    };
    const inputs = {
      arguments: await elements_prompt(questions.arguments),
      options: await elements_prompt(questions.options)
    };
    delete inputs.arguments.command;
    delete inputs.arguments.version;
    delete inputs.options.command;
    delete inputs.options.version;
    await command({
      args: { ...args,
        ...inputs.arguments
      },
      configuration: settings,
      options: { ...info._optionValues,
        ...inputs.options
      }
    });
  } else {
    /*
      ======================================
        If the options is an array and its length
        is zero, it means there may not be enough
        data entered by the user for it to function.
        In that case it should ask relevant questions
        about the command.
      ======================================
    */
    let questions = settings.arguments.questions;
    questions = [...questions, ...settings.options.map(o => o.question)];
    const input = await elements_prompt(questions);
    delete input.command;
    delete input.version;
    await command({
      input,
      settings
    });
  }
};

/* harmony default export */ var traditional_routes = (command => {
  /*
    ======================================
      All commands are higher order functions
      that accept some setting (that's inside
      the configuration file). And then we pass
      in the settings to that function so that it
      knows what needs to be done when it's called
      traditionally or through interactive CLI.
    ======================================
  */
  const settings = settings_configuration.commands.filter(c => c.name === command);
  const selected = routes_commands.hasOwnProperty(command) ? routes_commands[command] : null;
  return selected ? sanitize(...settings)(selected) : console.log;
});
// CONCATENATED MODULE: ./src/index.js
/*
  ======================================

     /$$                 /$$
    |__/                | $$
     /$$ /$$$$$$$   /$$$$$$$  /$$$$$$  /$$   /$$
    | $$| $$__  $$ /$$__  $$ /$$__  $$|  $$ /$$/
    | $$| $$  \ $$| $$  | $$| $$$$$$$$ \  $$$$/
    | $$| $$  | $$| $$  | $$| $$_____/  >$$  $$
    | $$| $$  | $$|  $$$$$$$|  $$$$$$$ /$$/\  $$
    |__/|__/  |__/ \_______/ \_______/|__/  \__/

    This file is the entry point of this CLI tool.
    There are basically two ways to pass in information
    to the script -

    1) Command Flags

    The 'commands' function takes care of parsing the
    argument list and then passing the information to the
    main processor (which lies inside `scripts`)

    2) Interactive CLI.

    The 'interactive' function below calls an interactive CLI -
    it first creates a banner from application name, then does
    what needs to be done and then prints out an exit message
    once everything's done.

  ======================================
*/







(async () => {
  const settings = {
    options: routes,
    commands: traditional_routes,
    data: {
      application: settings_application,
      configuration: settings_configuration
    }
  };
  process.argv.length > 2 ? await traditional(settings) : await interactive(settings);
})();

/***/ })
/******/ ]);